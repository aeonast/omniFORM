<!DOCTYPE html>
<html lang="en">
<head>
  <title>Connecting up Google Cardboard to web APIs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
  body {
    margin: 0px;
    overflow: hidden;
  }
  #webglviewer {
    bottom: 0;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
  }
  </style>
</head>
<body>
  <div id="webglviewer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min.js"></script>
  <script src="js/StereoEffect.js"></script>
  <script src="js/DeviceOrientationControls.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/utils.js"></script>
  <script src="js/ShapeDisplay.js"></script>

  <script>
  var scene, camera, renderer, element, container, effect, controls, clock;
  var shapeDisplay;
  var bSendToPhysical = false;
  var bRenderPhysical = true;

  init();
  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.001, 700);
    camera.position.set(-30, 30, 5);
    scene.add(camera);

    renderer = new THREE.WebGLRenderer();
    element = renderer.domElement;
    container = document.getElementById('webglviewer');
    container.appendChild(element);

    effect = new THREE.StereoEffect(renderer);

    // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
    controls = new THREE.OrbitControls(camera, element);
    controls.target.set(
      camera.position.x + 0.15,
      camera.position.y,
      camera.position.z
    );
    controls.noPan = true;
    controls.noZoom = true;

    // Our preferred controls via DeviceOrientation
    function setOrientationControls(e) {
      if (!e.alpha) {
        return;
      }
      controls = new THREE.DeviceOrientationControls(camera, true);
      controls.connect();
      controls.update();

      element.addEventListener('click', fullscreen, false);

      window.removeEventListener('deviceorientation', setOrientationControls, true);
    }
    window.addEventListener('deviceorientation', setOrientationControls, true);

    // Lighting
    var light = new THREE.PointLight(0x999999, 2, 100);
    light.position.set(50, 50, 50);
    scene.add(light);

    var lightScene = new THREE.PointLight(0x999999, 2, 100);
    lightScene.position.set(0, 5, 0);
    scene.add(lightScene);

    initShapeDisplay();

    clock = new THREE.Clock();

    setupSocket();
  }

  var sqrt, maxDistance;
  var normalizedPhase = 0;
  var speed = 0.06;
  var crests = 2;
  var distanceScalar = Math.PI * (crests * 2 - 1) / maxDistance;
  var distanceOffset = 2 * Math.PI;
  var maxAmplitude = 0.15;
  var heightScalar = 1.00 / (2 * maxAmplitude);
  var heightOffset = -0.9;

  function initShapeDisplay() {
    shapeDisplay = new ShapeDisplay(24, 24, 10, scene);
    shapeDisplay.setPosition(5, -5);

    var centerX = 15;
    var centerY = 15;
    maxDistance = Math.sqrt( (centerX-0)*(centerX-0) + (centerY-0)*(centerY-0) );

    sqrt = [];
    for (var x = 0; x < 30; x++) {
      for (var y = 0; y < 30; y++) {
        sqrt[x*30 + y] = Math.sqrt( (centerX-x)*(centerX-x) + (centerY-y)*(centerY-y) );
      }
    }
  }

  var fps = 24;
  function animate() {
    setTimeout(function() {
      requestAnimationFrame(animate);

      //if (!bRenderPhysical)
      //  updateDisplay();
      update(clock.getDelta());
      effect.render(scene, camera);
    }, 1000/fps);
  }

  function resize() {
    var width = container.offsetWidth;
    var height = container.offsetHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
    effect.setSize(width, height);
  }

  function update(dt) {
    resize();
    camera.updateProjectionMatrix();
    controls.update(dt);
  }

  function updateDisplay() {
    var time = Date.now();
    var frequency = 0.5;

    normalizedPhase += speed;
    var phase = 2 * Math.PI * normalizedPhase;

    var msg = "";
    for (var x = 0; x < shapeDisplay.xWidth; x++) {
      for (var y = 0; y < shapeDisplay.yWidth; y++) {
        var d = sqrt[x*30 + y];
        distance = distanceScalar * d + distanceOffset;
        var height = Math.sin(distance - phase) / distance;
        var h = heightScalar * height + heightOffset;

        shapeDisplay.setPinHeight(x, y, h);

        // GOTTA SCALE HEIGHT TO SHAPE DISPLAY!
        var hsend = (height * 100 + 80) * 1.5;
        msg += x + "," + y + "," + Math.abs(hsend) + "-";
      }
    }

    if (bSendToPhysical) {
      msg = msg.substring(0, msg.length - 1);
      socket.send(msg);
    }
  }

  function fullscreen() {
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    } else if (container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    }
  }

  function getURL(url, callback) {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState == 4) {
        if (xmlhttp.status == 200){
          callback(JSON.parse(xmlhttp.responseText));
        } else {
          console.log('We had an error, status code: ', xmlhttp.status);
        }
      }
    }
    xmlhttp.open('GET', url, true);
    xmlhttp.send();
  }

  function setupSocket(){
    console.log('Setup Socket!');
    socket = new WebSocket( get_appropriate_ws_url());

    try {
      socket.onopen = function() {
        console.log("Websocket connection OPEN");
        animate();
      }
      socket.onmessage = function got_packet(msg) {
        if (!bRenderPhysical)
          return;
        var data = handleMsg(msg.data);
      }
      socket.onclose = function(){
        console.log("websocket connection CLOSED");
      }
    } catch(exception) {
        alert('<p>Error' + exception);
    }
  }

  function handleMsg(msg) {
      var type = msg[0];
      pins = msg.substring(1).split("-");

      if (type == "T") {
        console.log("touch");
        for (var i = 0; i < pins.length; i++) {
          pins[i] = pins[i].split(",");
          var x = pins[i][0] - 0;
          var y = pins[i][1] - 0;
          var index = shapeDisplay.getIndex(x, y);
          shapeDisplay.shadowPins.push(index);
          //console.log(shapeDisplay.shadowPins);
        }
      }

      if (type == "S") {
        //console.log("shadow");
        for (var i = 0; i < pins.length; i++) {
          pins[i] = pins[i].split(",");
          var x = pins[i][0] - 0;
          var y = pins[i][1] - 0;
          var h = pins[i][2] - 0;

          // set the dark ones based on hand shadow
          var index = shapeDisplay.getIndex(x, y);

          if (shapeDisplay.shadowPins.indexOf(index) > 0)
          //if ((pins[i][2] > 0) || shapeDisplay.shadowPins.indexOf(index) > 0)
            shapeDisplay.setPinMaterial(index, true);
          else
            shapeDisplay.setPinMaterial(index, false);
        }
        shapeDisplay.shadowPins = [];
      }

      else if (type == "H") {
        //console.log("heights");
        for (var i = 0; i < pins.length; i++) {
          pins[i] = pins[i].split(",");
          var x = pins[i][0] - 0;
          var y = pins[i][1] - 0;
          var h = pins[i][2] - 0;

          // set heights from physical display

            var oldHeight = shapeDisplay.getLastPinHeight(x, y);
            var diff = Math.abs(h - oldHeight);

          if (!isNaN(h) && (diff > 3)) {
            shapeDisplay.setPinHeight(x, y, h/255*4 -4);
          }
          shapeDisplay.setLastPinHeight(x, y, h);
        }
      }
  }

  addEventListener("keydown", function(event) {
    console.log("KeyDown: " + event.keyCode);
    switch(event.keyCode) {
        case 32:  // SPACE
          bRenderPhysical = !bRenderPhysical;
          console.log("Render Physical:  " + bRenderPhysical)
        break;
        case 13:  // ENTER
          bSendToPhysical = !bSendToPhysical;
          console.log("Send To Physical: " + bSendToPhysical);
          break;
    }
  });

  </script>
</body>
</html>
